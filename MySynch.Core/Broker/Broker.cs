using System;
using System.Collections.Generic;
using System.Linq;
using System.ServiceModel;
using System.Threading.Tasks;
using MySynch.Common.IOC;
using MySynch.Common.Logging;
using MySynch.Common.Serialization;
using MySynch.Contracts;
using MySynch.Contracts.Messages;
using MySynch.Proxies.Autogenerated.Interfaces;

namespace MySynch.Core.Broker
{
    [ServiceBehavior(InstanceContextMode = InstanceContextMode.Single)]
    public class Broker:IBroker
    {
        private IEnumerable<Registration> _registrations;
        private StoreType _store;
        private IStore<Registration> _storeHandler;
        private List<BrokerMessage> _receivedMessages;
        private MySynchComponentResolver _componentResolver;
        internal virtual SortedList<string, ISubscriberProxy> InitiatedSubScriberProxies { get; set; }
        private object _lock= new object();

        public GetHeartbeatResponse GetHeartbeat()
        {
            return new GetHeartbeatResponse {Status = true,RootPath=""};
        }

        public Broker(StoreType storeType, MySynchComponentResolver componentResolver)
        {
            try
            {
                _store = storeType;
                _componentResolver = componentResolver;
                _storeHandler = _componentResolver.Resolve<IStore<Registration>>(storeType.StoreTypeName);
                _registrations =
                    _storeHandler.GetMethod(_store.StoreName);
                _receivedMessages=new List<BrokerMessage>();
                InitiatedSubScriberProxies= new SortedList<string, ISubscriberProxy>();
            }
            catch (ComponentNotRegieteredException ex)
            {
                LoggingManager.LogMySynchSystemError(ex);
                throw;
            }
            catch (Exception ex)
            {
                LoggingManager.LogMySynchSystemError(ex);
                _registrations = new List<Registration>();
            }
        }

        public AttachResponse Attach(AttachRequest request)
        {
            LoggingManager.Debug("Attaching attempt to the Broker...");
            using (LoggingManager.LogMySynchPerformance())
            {
                if (request == null || request.RegistrationRequest == null ||
                    string.IsNullOrEmpty(request.RegistrationRequest.ServiceUrl))
                {
                    LoggingManager.Debug("Not attached due to empty request.");
                    return new AttachResponse {RegisteredOk = false};
                }
                try
                {
                    if (_registrations.Any(r => r.ServiceUrl == request.RegistrationRequest.ServiceUrl))
                    {
                        LoggingManager.Debug("Attached to old " + request.RegistrationRequest.ServiceUrl);
                        return new AttachResponse {RegisteredOk = true};
                    }
                    _registrations =
                        _registrations.ToList().AddRegistration(request.RegistrationRequest).SaveAndReturn(
                            _store.StoreName, _storeHandler.StoreMethod);
                    LoggingManager.Debug("Attached to new " + request.RegistrationRequest.ServiceUrl);
                    return new AttachResponse {RegisteredOk = true};
                }
                catch (Exception ex)
                {
                    LoggingManager.LogMySynchSystemError(ex);
                    LoggingManager.Debug("Not attached " + request.RegistrationRequest.ServiceUrl);
                    return new AttachResponse {RegisteredOk = false};
                }
                finally
                {
                    LoggingManager.Debug("Attached services: " + string.Join(", ",_registrations.Select(r=>r.ServiceUrl)));
                }
            }
        }

        public DetachResponse Detach(DetachRequest request)
        {
            LoggingManager.Debug("Detaching attempt to the Broker...");
            if (request == null || string.IsNullOrEmpty(request.ServiceUrl))
            {
                LoggingManager.Debug("Not detached ");
                return new DetachResponse { Status = false };
            }
            try
            {
                if (!_registrations.Any(r => r.ServiceUrl == request.ServiceUrl))
                {
                    LoggingManager.Debug("Not detached " + request.ServiceUrl);
                    return new DetachResponse { Status = false };
                }
                _registrations =
                    _registrations.ToList().RemoveRegistration(request.ServiceUrl).SaveAndReturn(
                        _store.StoreName,_storeHandler.StoreMethod);
                LoggingManager.Debug("Detached :" + request.ServiceUrl);
                return new DetachResponse { Status = true };
            }
            catch (Exception ex)
            {
                LoggingManager.LogMySynchSystemError(ex);
                LoggingManager.Debug("Not detached " + request.ServiceUrl);
                return new DetachResponse { Status = false };
            }
            finally
            {
                LoggingManager.Debug("Attached services: " + string.Join(", ", _registrations.Select(r => r.ServiceUrl)));
            }
        }

        public ListAllRegistrationsResponse ListAllRegistrations()
        {
            return new ListAllRegistrationsResponse {Registrations = _registrations.ToList()};
        }

        public void ReceiveAndDistributeMessage(ReceiveAndDistributeMessageRequest request)
        {
            LoggingManager.Debug("Received request from publisher.");
            var brokerMessage = request.PublisherMessage.ConvertToBrokerMessage();
            _receivedMessages.Add(brokerMessage);
            DistributeMessageToAllAvailableSubscribers(brokerMessage);
            LoggingManager.Debug("Request forwarded to all subscribers.");
        }

        internal void DistributeMessageToAllAvailableSubscribers(BrokerMessage brokerMessage)
        {
            var availableSubscribers =
                _registrations.Where(
                    r =>
                    r.ServiceRole == ServiceRole.Subscriber && r.OperationTypes.Contains(brokerMessage.OperationType));
            if (!availableSubscribers.Any())
                return;
            brokerMessage.Destinations =
                availableSubscribers.Select(
                    s => new Destination {DestinationUrl = s.ServiceUrl, ProcessedByDestination = false,ParentMessage=brokerMessage as PublisherMessage}).ToList();
            List<Task> tasks= new List<Task>();
            LoggingManager.Debug("Trying to distribute to: " + string.Join(", ",brokerMessage.Destinations.Select(d=>d.DestinationUrl)));
            foreach (var destination in brokerMessage.Destinations)
            {
                Destination destination1 = destination;
                Task task = new Task(()=>DistributeMessageToSubscriber(destination1));
                tasks.Add(task);
                task.Start();
            }
        }

        internal void DistributeMessageToSubscriber(object destination)
        {
            Destination subscriberDestination = ((Destination) destination);
            var subscriberRemote = GetOrCreateAProxy(subscriberDestination.DestinationUrl);
            if (subscriberRemote == null)
            {
                LoggingManager.Debug("Did not distribute to subscriber: " + subscriberDestination.DestinationUrl +
                                     ". Subscriber dead or unreachable at the moment.");
                subscriberDestination.ProcessedByDestination = false;
                return;
            }
            try
            {
                ReceiveMessageRequest request = new ReceiveMessageRequest { PublisherMessage = subscriberDestination.ParentMessage };
                var response = subscriberRemote.ReceiveMessage(request);
                subscriberDestination.ProcessedByDestination = response.Success;
                LoggingManager.Debug("Distributed to subscriber: " + subscriberDestination.DestinationUrl);

            }
            catch (Exception ex)
            {
                LoggingManager.LogMySynchSystemError(ex);
                subscriberDestination.ProcessedByDestination = false;
            }
        }

        internal ISubscriberProxy GetOrCreateAProxy(string destinationUrl)
        {
            lock (_lock)
            {
                try
                {
                    if (InitiatedSubScriberProxies.ContainsKey(destinationUrl))
                        return InitiatedSubScriberProxies[destinationUrl];

                    var subscriberRemote = _componentResolver.Resolve<ISubscriberProxy>("ISubscriber.Remote");
                    subscriberRemote.InitiateUsingServerAddress(destinationUrl);
                    InitiatedSubScriberProxies.Add(destinationUrl, subscriberRemote);
                    return subscriberRemote;
                }
                catch (Exception ex)
                {
                    LoggingManager.LogMySynchSystemError(ex);
                    return null;
                }
            }
        }

        public ListAllMessagesResponse ListAllMessages()
        {
            return new ListAllMessagesResponse {AvailableMessages = _receivedMessages};
        }
    }
}
